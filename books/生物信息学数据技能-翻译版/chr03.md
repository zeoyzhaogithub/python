## 第三章、补充Unix Shell知识

&emsp;&emsp;Unix shell是生物信息学的基础计算环境。shell作为我们与大型生物信息学程序的接口，作为检查数据和中间结果的交互式控制台，以及作为我们的管道和工作流的基础设施。本章将帮助您熟练掌握本书其余部分广泛使用的必要Unix shell概念。这将允许您在以后的章节中专注于命令的内容，而不是专注于理解shell语法。
      
&emsp;&emsp;本书假设您熟悉基本主题，例如终端是什么，shell是什么，Unix文件系统层次结构，移动目录，文件权限，执行命令，以及使用文本编辑器。如果这些主题听起来对你来说是陌生的，最好使用更多的基础材料(有关一些资源，请参见第16页上的“本书所作的假设”)。在本章中，我们将涵盖在生物信息学中如何使用shell的基本概念：流、重定向、管道、使用正在运行的程序和命令替换。理解这些shell主题将为您使用shell处理数据(第7章)，构建管道和工作流(第12章)做好准备。在本章中，我们还将了解为什么Unix shell在我们如何进行现代生物信息学中具有如此突出的作用。如果您已经对这些shell主题感到舒服，我建议您阅读本章的第一节，然后跳到第4章。

### 为什么我们在生物信息学中使用Unix？模块化和Unix原理
       
&emsp;&emsp;想象一下，我们不是使用Unix shell作为我们的生物信息学计算环境，而是将我们的整个项目作为单个大型程序来实现。我们通常不认为生物信息学项目是一个“程序”，但它当然可以是-我们可以编写一个单一的复杂程序，将原始数据作为输入，经过数小时的数据处理后，输出出版所需的数据和最终的结果表。对于像变体调用这样的项目，该程序将包括原始序列读取处理、读取映射、变体调用、筛选变体调用和最终数据分析的步骤。这个程序的代码将是巨大的-很容易就有数千行。
       
&emsp;&emsp;虽然像这样的程序具有针对特定变体调用项目进行定制的好处，但它的通用性还不足以适应其他项目。考虑到其巨大的代码量，这个程序将是不切实际的调整，以适应每个新的项目。庞大的代码库也会使查找和修复bug变得困难。更糟糕的是，除非我们的单片程序被明确编程为检查步骤之间的数据看起来没有错误，否则步骤可能会出错(我们不知道)，它会尽职尽责地继续对不正确的数据进行分析。虽然这个定制程序可能在计算上更有效率，但这会以脆弱、难以修改、容易出错(因为它使检查中间数据非常困难)，并且不能推广到未来的项目中为代价。
       
&emsp;&emsp;UNIX是生物信息学中的基础计算环境，因为它的设计理念是这种僵化和脆弱的方法的对立面。Unix shell被设计成允许用户通过将较小的模块化程序连接在一起来轻松地构建复杂的程序。这种方法就是Unix哲学：
>This is the Unix philosophy: Write programs that do one thing and do it well. Write
programs to work together. Write programs to handle text streams, because that is a
universal interface.
—Doug McIlory

&emsp;&emsp;Unix shell为这些程序提供了一种相互通信(管道)以及写入和读取文件(重定向)的方法。UNIX的核心程序(我们将在第7章中用来分析命令行上的数据)是模块化的，并且设计为与其他程序很好地配合使用。Unix哲学的模块化方法在生物信息学中有许多优势：
1.	使用模块化工作流，可以更容易地发现错误并找出错误发生的位置。在模块化工作流中，每个组件都是独立的，这使得检查中间结果是否不一致和隔离有问题的步骤变得更加容易。相反，大型的非模块化程序隐藏了潜在的问题(您所看到的只是它的最终输出数据)，并且使得定位问题产生的地方变得困难。
2.	模块化工作流使我们能够试验其他方法和方法，因为单独的组件可以很容易地与其他组件互换。例如，如果您怀疑某个特定的校准器对您的数据的处理效果不佳，那么很容易将这个校准器换成另一个校准器。这只有在模块化工作流中才有可能，其中我们的比对程序与下游步骤如变体调用或RNA-seq分析分开。
3.	模块化组件允许我们选择适合特定任务的工具和语言。这是Unix环境非常适合生物信息学的另一个原因：它允许我们组合命令行工具来交互地探索数据(在第7章中将更深入地讨论)，Python用于更复杂的脚本编写，R用于统计分析。当程序被设计为与其他程序一起工作时，为特定任务选择专门的工具是没有成本的-这是我们在生物信息学中经常做的事情。
4.	模块化程序是可重用的，适用于多种类型的数据。编写良好的模块化程序可以重新组合并应用于不同的问题和数据集，因为它们是独立的部分。最重要的是，通过重新混合模块化组件，可以用现有的工具解决新的问题。
        
&emsp;&emsp;除了强调程序的模块化和接口，McIlroy的引用还提到了文本流。我们将在本章中讨论Unix流，但是流的概念在我们如何处理大型数据时非常重要。大数据的定义可能会有所不同，虽然单通道测序数据对于一个刚进入测序的实验室来说可能很大，但与较大的测序中心每小时处理的数据相比，这是微不足道的。无论如何，排序数据的通道太大，无法放入大多数标准台式机的内存中。如果我需要在这个数据中搜索确切的字符串“GTGATTAACTGCGAA”，我无法在记事本中打开一条数据通道并使用查找功能来确定它发生的位置-根本没有足够的内存来在内存中保存所有这些核苷酸。相反，工具必须依赖数据流，从源中读取并主动处理。通用Unix工具和许多生物信息学程序都设计为通过流获取输入，并通过不同的流传递输出。正是这些文本流允许我们将程序耦合到工作流中并处理数据，而无需将大量数据存储在计算机的内存中。

!['suggestion'](../../img/suggestion.png)各种类型的Unix shell命令

    在本书中，我将经常提到的不仅仅是单一的unix shell命令。Shell是计算机程序，许多程序员设计并实现了他们自己的版本。这许多版本可能会给新用户带来令人沮丧的问题，因为一些shell的功能与其他shell不兼容。
    为了避免这种问题，请确保您使用的是Bourne-Again shell或bash。Bash应用较为广泛，是苹果OS X和Ubuntu Linux等操作系统上的默认shell。您可以运行echo$shell来验证您是否正在使用bash作为shell(最好也检查echo$0表示的内容，因为即使您确定使用哪种shell，如何识别shell也是不同的！)。我不推荐其他shell，如C shell(Csh)、其后代tcsh和Korn shell(Ksh)，因为这些在生物信息学中不太流行，可能与本书中的示例不兼容。Bourne shell(Sh)是Bourne-Again shell(Bash)的前身；但是bash更新，通常更受欢迎。
    可以使用chsh命令更改shell。在我的日常生物信息学工作中，我使用Z shell(Zsh)，并将其作为我的默认shell。Z shell有很多先进的功能(例如，更好的自动运行功能)，在生物信息学中应用较为广泛。除非另有说明，否则本书中的所有内容均是以这两个shell为主。如果你对一般的shell基本知识有信心，你可能想试试Z shell。我已经在GitHub上本章的README文件中包含了关于Z shell的资源。

&emsp;&emsp;关于Unix shell的最后一点要强调的是它难以置信的强大。有了通配符等简单功能，将命令应用于数百个文件就变得轻而易举了。但是这种能力也带来了风险：Unix shell不关心命令是否输入错误或者它们是否会销毁文件；Unix shell不是为了防止你做不安全的事情而设计的。加里·伯恩哈特(Gary Bernhardt)打了一个很好的比喻：Unix就像一把电锯。电锯是强大的工具，使许多困难的任务，如切割厚厚的原木相当容易。不幸的是，这种力量伴随着危险：电锯可以很容易地穿过你的腿(嗯，技术上更容易)。例如，考虑：

```shell
$ rm -rf tmp-data/aligned-reads* # deletes all old large files
$ # versus
$ rm -rf tmp-data/aligned-reads * # deletes your entire current directory
rm: tmp-data/aligned-reads: No such file or directory
```

&emsp;&emsp;在Unix中，一个空格可能意味着清理一些旧文件和延迟完成项目之间的区别，因为您不小心删除了所有内容。这是使用强大工具的结果，不应该引起恐慌。相反，在试验或尝试新命令时只需采取谨慎的态度(例如，在临时目录中工作，如果不确定命令的行为，则使用假文件或数据，并始终保留备份)。Unix shell设计的一个重要部分就是，有能力让你做很强大的(可能不安全的)操作：
 
>Unix was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things.
—Doug Gwyn
       
&emsp;&emsp;高级生物信息学家必备技能之一是以聪明的方式处理重复的大型数据处理任务。而shell通常是完成这些任务最快的工具。在本章中，我们将重点介绍一些Unix shell基础概念，这些基础概念可以帮助我们从简单的部分构建复杂的程序：流、重定向、管道、使用进程和命令替换。nix shell的另一个重要部分是多关于自动化任务的知识，我们将在第12章学习更多这方面的内容。

### 使用流和重定向

&emsp;&emsp;生物信息学数据通常是文本，例如，测序读取文件或参考基因组中的AS、Cs、Ts和Gs或基因坐标的制表符分隔文件。生物信息学中的文本数据通常也很大(千兆字节或超过计算机内存的数据)。这就是为什么Unix处理文本流的哲学在生物信息学中是有用的：文本流允许我们对数据流进行处理，而不是将其全部保存在内存中。
     
&emsp;&emsp;例如，假设我们在一个FASTA文件中有两个充满核苷酸序列的大文件，这是一种用于存储序列数据的标准文本格式(通常是DNA，但偶尔也是蛋白质)。即使是将这两个大文件合并为一个文件的简单任务，一旦这些文件的大小达到几千兆字节，也会变得很棘手。在不使用Unix shell的情况下，如何完成这个简单的任务？您可以尝试打开一个文件，选择并复制其所有内容，然后将其粘贴到另一个文件中。然而，这不仅需要将两个文件加载到内存中，而且在选择“全部”、“复制”和“粘贴”时，还需要使用额外的内存来制作一个文件的另一个副本。像这样的方法不能扩展到我们在生物信息学中经常使用的数据的大小。此外，将内容粘贴到文件中并不遵循第1章：将数据视为只读的建议。如果出现错误，其中一个文件(或两个文件！)很容易损坏。更糟糕的是，复制和粘贴大文件会占用大量内存，因此您的计算机更有可能出现问题。Streams为这些问题提供了可伸缩的、健壮的解决方案。

### 将标准输出重定向到文件

&emsp;&emsp;Unix shell通过利用流简化了组合大型文件等任务。使用流可以防止我们将不必要地大文件加载到内存中。相反，我们可以通过将大文件的内容打印到标准输出流来组合大文件，并将此流从终端重定向到我们希望保存组合结果的文件中。您可能已经使用程序cat将文件的内容打印到标准输出(当不重定向时将打印到您的终端屏幕)。例如，我们可以使用cat将tb1-protein.fasta文件(可在本章GitHub上的目录中找到)打印到标准输出：

```shell
$ cat tb1-protein.fasta&gt;teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
```

&emsp;&emsp;cat还允许我们按照它们在命令参数中出现的顺序，将多个文件的内容打印到标准输出流中。这实质上连接了这些文件，如这里所示，与tb1和tga1翻译的序列：

```shell
$ cat tb1-protein.fasta tga1-protein.fasta&gt;teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
>teosinte-glume-architecture-1 protein
DSDCALSLLSAPANSSGIDVSRMVRPTEHVPMAQQPVVPGLQFGSASWFP
RPQASTGGSFVPSCPAAVEGEQQLNAVLGPNDSEVSMNYGGMFHVGGGSG
GGEGSSDGGT
```
&emsp;&emsp;虽然这些文件已经连接，但结果不会保存在任何地方-这些行只是打印到终端屏幕上。为了将这些连接的结果保存到文件中，您需要将这个标准输出流从终端屏幕重定向到一个文件。重定向是Unix中的一个重要概念，也是您在生物信息学中经常使用的一个概念。
&emsp;&emsp;我们使用运算符>或>>将标准输出重定向到文件。运算符>将标准输出重定向到文件并覆盖该文件的任何现有内容(请注意并小心使用者一点)，而后一个运算符>>则讲内容附加到文件中(保留内容并仅添加到末尾)。如果该文件不存在，两个操作符都会在将输出重定向到它之前创建该文件。为了连接我们的两个FASTA文件，我们像之前那样使用cat，但将输出重定向到一个文件：
```shell
$ cat tb1-protein.fasta tga1-protein.fasta > zea-proteins.fasta
```
&emsp;&emsp;请注意，当您将标准输出重定向到文件时，不会将任何内容打印到终端屏幕上。在我们的示例中，整个标准输出流最终位于zea-proteins.fasta文件中。将标准输出流重定向到文件，如图3-1(B)所示。

图3-1、(a)未重定向的标准输出、标准错误和标准输入(灰框是打印到用户终端的内容)；(b)重定向到文件的标准输出。
       
&emsp;&emsp;我们可以通过检查此目录中最新创建的文件是否是我们刚刚创建的文件(即zea-proteins.fasta)来验证我们的重定向工作是否正确：
```shell 
ls -lrttotal 24
-rw-r--r-- 1 vinceb staff 353 Jan 20 21:24 tb1-protein.fasta
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tga1-protein.fasta
-rw-r--r-- 1 vinceb staff 505 Jan 20 21:35 zea-proteins.fasta
```
&emsp;&emsp;将-lrt添加到ls中以列表格式(-l)、反向(-r)、时间(-t)顺序列出此目录中的文件(更多详细信息，请参见man ls)。另外，请注意这些标志是如何组合到-lrt中的；这是一种常见的语法快捷方式。如果希望在顶部看到最新的文件，可以省略r标志。

### 重定向标准错误

&emsp;&emsp;由于许多程序使用标准输出流来输出数据，因此需要单独的流来处理错误、警告和要由用户读取的消息。标准错误是仅用于此目的流(如图3-1所示)。与标准输出一样，默认情况下，标准错误直接发送到您的终端。在实践中，我们经常希望将标准错误流重定向到文件，以便将消息、错误和警告记录到稍后可以检查的文件中。
       
&emsp;&emsp;为了说明如何重定向标准输出和标准错误，我们将使用命令ls-l列出一个现有文件(tb1.fast a)和一个不存在的文件(foly1.fast a)。现有文件tb1.fast a的ls-l的输出将被发送到标准输出，而一条错误消息，说明foly1.fasta不存在，将被输出到标准错误。当您不重定向任何内容时，两个流都会输出到您的终端：
```shell
$ ls -l tb1.fasta leafy1.fastals: leafy1.fasta: No such file or directory
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:58 tb1.fasta
```
&emsp;&emsp;要将每个流重定向到单独的文件，我们将上一节中的>运算符与用于重定向标准错误流2>的新运算符相结合：
```shell
$ ls -l tb1.fasta leafy1.fasta &gt; listing.txt 2&gt; listing.stderr$ cat listing.txt
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tb1.fasta
$ cat listing.stderr
ls: leafy1.fasta: No such file or directory
```
&emsp;&emsp;此外，2>具有2>>这类似于>>(它将附加到文件而不是覆盖它)。

!['suggestion'](../../img/suggestion.png)文件描述符

       2表示法可能看起来很神秘(并且很难记忆)，但是标准错误的重定向操作符中包含2是有原因的。Unix系统上的所有打开文件(包括流)都被分配一个称为文件描述符的唯一整数。UNIX的三个标准流-标准输入(稍后将看到)、标准输出和标准错误-分别被赋予文件描述符0、1和2。甚至可以使用1作为标准输出的重定向运算符，尽管这在实践中并不常见，可能会使合作者感到困惑。
       
       偶尔，一个程序会产生我们不需要或不关心的消息。重定向是一种有用的方法，可以静默一些程序写入标准输出的诊断信息：我们只需重定向到stderr.txt这样的日志文件。然而，在某些情况下，我们不需要将此输出保存到文件中，将输出写入物理磁盘可能会降低程序的速度。幸运的是，类Unix操作系统有一个特殊的“伪”磁盘(称为伪设备)，可以将不需要的输出重定向到：/dev/null。写入/dev/null的输出会消失，这就是为什么它有时被书呆子们戏称为“黑洞”的原因。

!['suggestion'](../../img/suggestion.png)使用tail-f监控重定向标准错误

    对于可能运行数天(或可能数周，或数月！)的大型生物信息学程序，我们经常需要重定向标准输出和标准错误。重定向这两个流后，不会将任何内容打印到您的终端，包括您可能希望在长时间运行的任务期间监视的有用诊断消息。如果希望遵循这些消息，可以使用程序tail通过调用tail filename.txt来查看输出文件的最后几行。例如，运行tail stderr.txt将打印文件stderr.txt的最后10行。您可以使用-n选项设置tail将打印的确切行数。
       
    tail还可以用来不断监视带有-f的文件(后面是-f)。随着被监控文件的更新，Tail将在您的终端屏幕上显示新行，而不是像没有此选项那样只显示10行并退出。如果希望停止对文件的监视，可以使用Control-C中断尾部进程。当您关闭Tail时，写入文件的进程不会被中断。

### 使用标准输入重定向

&emsp;&emsp;Unix shell还为标准输入提供了重定向运算符。通常标准输入来自键盘，但使用<重定向操作符，您可以直接从文件中读取标准输入。虽然标准输入重定向不如>、>>和2>常见，但它偶尔还是有用的：

```shell
$ program < inputfile > outputfile
```

&emsp;&emsp;在这个例子中，人工文件inputfile通过标准输入提供给程序，并且程序的所有标准输出都被重定向到文件outputfile。
使用Unix管道(例如cat inputfile|program>output file)比使用<更常见一些。我们稍后将看到的许多程序(如grep、awk、sort)除了通过标准输入进行输入外，还可以接受文件参数。其他程序(特别是在生物信息学中常见)使用单个破折号参数(-)来指示它们应该使用标准输入，但这是一个约定，而不是Unix的一个功能。

&emsp;&emsp;万能的Unix管道：速度与效率合二为一

>We should have some ways of connecting programs like [a] garden hose—screw in
another segment when it becomes necessary to massage data in another way.
—Doug McIlory (1964)

&emsp;&emsp;在第37页McIlroy的引用“为什么我们在生物信息学中使用Unix？模块化和Unix哲学“包括了相关建议，”写程序一起工作“。这要归功于Unix管道，这是McIlroy自己发明的一个概念。UNIX管道与我们之前看到的重定向操作符类似，不同之处在于管道将程序的标准输出流重定向到文件，而不是将其重定向到另一个程序的标准输入。只有标准输出通过管道传输到下一个命令；标准错误仍然打印到终端屏幕，如图3-2所示。
图3-2、通过管道将标准输出从Program1传输到Program2；标准错误仍然打印到用户的终端

&emsp;&emsp;您可能想知道为什么我们将一个程序的标准输出直接重定向到另一个程序的标准输入中，而不是将输出写入一个文件，然后将这个文件读入下一个程序。在许多情况下，创建文件将有助于检查中间结果并且可以调试工作流的步骤-那么为什么不能每次都这样做呢？
       
&emsp;&emsp;答案是，它通常归结为计算效率-读取和写入磁盘非常慢。我们在生物信息学中使用管道(相当强制)，不仅因为它们是构建管道的有用方式，而且因为它们更快(在某些情况下，更快得多)。现代磁盘比内存慢几个数量级。现代磁盘比内存慢几个数量级。例如，从内存读取1兆字节的数据只需要大约15微秒，但是从磁盘读取1兆字节的数据需要2毫秒。这2毫秒是2，000微秒，使得从磁盘读取的速度慢了100多倍(这是一个估计值；实际数字将根据您的磁盘类型和速度而变化)。
       
&emsp;&emsp;在实践中，从磁盘写入或读取(例如，在将标准输出重定向到文件期间)通常是数据处理中的瓶颈。对于下一代大型测序数据，这可能会大大减慢速度。如果您实现了一个比旧版本快两倍的聪明算法，那么如果真正的瓶颈是读取或写入磁盘，您甚至可能没有注意到差异。此外，不必要地将输出重定向到文件会占用磁盘空间。对于下一代大型数据和潜在的许多实验样本，这可能是一个相当大的问题。
       
&emsp;&emsp;通过管道将一个程序的输出直接传递到另一个程序的输入中，是一种计算高效且简单的Unix程序接口方式。这是生物信息学家(以及一般的软件工程师)喜欢Unix的另一个原因。管道允许我们从较小的模块部分构建更大、更复杂的工具。用什么语言编写程序也无关紧要；只要两个程序都理解它们之间传递的数据，管道就可以在任何东西之间工作。作为大多数程序之间最低的公分母，经常使用纯文本流-这是McIlroy在他关于Unix哲学的引用中提出的观点。

### 执行管道：使用grep和Pipes创建简单程序
       
&emsp;&emsp;生物信息学的黄金法则是不要相信你的工具或数据。这种怀疑论要求对中间结果进行持续的健全检查，以确保您的方法不会使数据产生偏差，或者数据中的问题不会因您的方法而加剧。然而，编写定制脚本来检查中间数据的每一位可能会很昂贵，即使您是一个快速的程序员，可以在第一次编写没有bug的代码。UNIX管道允许我们快速且迭代地构建微小的命令行程序来检查和操作数据-我们将在第7章中更深入地探讨这种方法。管道还广泛用于更大的生物信息学工作流(第12章)，因为它们避免了将不必要的文件写入磁盘的延迟问题。我们将在本节中学习管道的基础知识，准备在本书的其余部分中使用它们。
       
&emsp;&emsp;让我们看看如何使用管道将进程链接在一起。假设我们正在使用一个FASTA文件，并且一个程序警告它在序列中包含非核苷酸字符。你会对此感到惊讶，因为序列只是DNA。我们可以使用管道和grep的Unix单行代码轻松地检查非核苷酸字符。grep unix工具在文件或标准输入中搜索匹配模式的字符串。这些模式可以是简单的字符串，也可以是正则表达式(实际上有两种类型的正则表达式，基本表达式和扩展表达式；有关更多详细信息，请参见man grep)。如果您不熟悉正则表达式，请参阅该书的GitHub存储库的Readme中的参考资料。
       
&emsp;&emsp;我们的管道将首先从FASTA文件中删除所有标题行(以>开头的行)，因为我们只关心序列是否具有非核苷酸字符。然后，可以将FASTA文件的其余序列通过管道传输到grep的另一个实例，该实例只打印包含非核苷酸字符的行。为了使这些字符在我们的终端中更容易识别，我们还可以为这些匹配的字符上色。整个命令将如下所示：

```shell
$ grep -v "^>" tb1.fasta | \    (1)
 grep --color -i "[^ATCG]"      (2)
CCCCAAAGACGGACCAATCCAGCAGCTTCTACTGCTAYCCATGCTCCCCTCCCTTCGCCGCCGCCGACGC
```

(1)首先，我们删除以>字符开头的FASTA标题行。我们的正则表达式模式是^>，它匹配以>字符开头的所有行。插入符号在正则表达式中有两种含义，但在此上下文中，它用于将模式锚定到行首。因为我们想要排除以>开头的行，所以我们使用grep选项-v反转匹配的行。最后，我们使用管道字符(|)将标准输出通过管道传输到下一个命令。反斜杠(\)字符只是表示我们将在下一行继续执行命令，上面使用该字符是为了提高可读性。

(2)其次，我们希望找到不是A、T、C或G的任何字符。最容易构造与A、T、C或G不匹配的正则表达式模式。为此，我们在正则表达式中使用插入符号的第二个含义。在括号中使用时，插入符号匹配不是这些括号中的字符之一的任何字符。因此，模式[^ATCG]匹配任何不是A、T、C或G的字符。此外，我们忽略-i的大小写，因为a、t、c和g是有效的核苷酸(小写字符通常用于表示屏蔽重复或低复杂性序列)。最后，我们添加grep的-color选项来为匹配的非核苷酸字符着色。

&emsp;&emsp;在终端窗口中运行时，这将突出显示“Y”。有趣的是，根据IUPAC设定的标准，Y实际上是有效的扩展二义性核苷酸编码。Y表示嘧啶碱基：C或T。其他单字母IUPAC代码可以表示序列数据中的不确定性。例如，嘌呤碱基由R表示，而A、G或T的碱基具有代码D。
      
&emsp;&emsp;让我们讨论一下关于这个简单的Unix管道的几个附加问题。首先，注意两个正则表达式都用引号引起来，这是一个很好的习惯。此外，如果我们使用grep-v tb1.fasta，您的shell会将>解释为重定向运算符，而不是提供给grep的模式。不幸的是，这会错误地覆盖您的tb1.fasta文件！大多数生物信息学家在某种程度上都犯过这个错误，并从中吸取了教训(通过丢失他们希望grep的Fasta文件)，所以要小心。
      
&emsp;&emsp;这个简单的Unix单行代码编写和运行只需要几秒钟，非常适合这个特定的任务。我们可以编写一个更复杂的程序，显式地解析FASTA格式，计算出现的次数，并输出带有非核苷酸字符的序列名称列表。然而，对于我们的任务-查看程序为什么不工作-动态构建简单的命令行工具是快速和足够的。在第7章中，我们将看到更多如何使用Unix数据程序和管道构建命令行工具的示例。

### 管道和重定向组合使用