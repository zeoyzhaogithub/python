## 第三章、补充Unix Shell知识

&emsp;&emsp;Unix shell是生物信息学的基础计算环境。shell作为我们与大型生物信息学程序的接口，作为检查数据和中间结果的交互式控制台，以及作为我们的管道和工作流的基础设施。本章将帮助您熟练掌握本书其余部分广泛使用的必要Unix shell概念。这将允许您在以后的章节中专注于命令的内容，而不是专注于理解shell语法。
      
&emsp;&emsp;本书假设您熟悉基本主题，例如终端是什么，shell是什么，Unix文件系统层次结构，移动目录，文件权限，执行命令，以及使用文本编辑器。如果这些主题听起来对你来说是陌生的，最好使用更多的基础材料(有关一些资源，请参见第16页上的“本书所作的假设”)。在本章中，我们将涵盖在生物信息学中如何使用shell的基本概念：流、重定向、管道、使用正在运行的程序和命令替换。理解这些shell主题将为您使用shell处理数据(第7章)，构建管道和工作流(第12章)做好准备。在本章中，我们还将了解为什么Unix shell在我们如何进行现代生物信息学中具有如此突出的作用。如果您已经对这些shell主题感到舒服，我建议您阅读本章的第一节，然后跳到第4章。

### 为什么我们在生物信息学中使用Unix？模块化和Unix原理
       
&emsp;&emsp;想象一下，我们不是使用Unix shell作为我们的生物信息学计算环境，而是将我们的整个项目作为单个大型程序来实现。我们通常不认为生物信息学项目是一个“程序”，但它当然可以是-我们可以编写一个单一的复杂程序，将原始数据作为输入，经过数小时的数据处理后，输出出版所需的数据和最终的结果表。对于像变体调用这样的项目，该程序将包括原始序列读取处理、读取映射、变体调用、筛选变体调用和最终数据分析的步骤。这个程序的代码将是巨大的-很容易就有数千行。
       
&emsp;&emsp;虽然像这样的程序具有针对特定变体调用项目进行定制的好处，但它的通用性还不足以适应其他项目。考虑到其巨大的代码量，这个程序将是不切实际的调整，以适应每个新的项目。庞大的代码库也会使查找和修复bug变得困难。更糟糕的是，除非我们的单片程序被明确编程为检查步骤之间的数据看起来没有错误，否则步骤可能会出错(我们不知道)，它会尽职尽责地继续对不正确的数据进行分析。虽然这个定制程序可能在计算上更有效率，但这会以脆弱、难以修改、容易出错(因为它使检查中间数据非常困难)，并且不能推广到未来的项目中为代价。
       
&emsp;&emsp;UNIX是生物信息学中的基础计算环境，因为它的设计理念是这种僵化和脆弱的方法的对立面。Unix shell被设计成允许用户通过将较小的模块化程序连接在一起来轻松地构建复杂的程序。这种方法就是Unix哲学：
>This is the Unix philosophy: Write programs that do one thing and do it well. Write
programs to work together. Write programs to handle text streams, because that is a
universal interface.
—Doug McIlory

&emsp;&emsp;Unix shell为这些程序提供了一种相互通信(管道)以及写入和读取文件(重定向)的方法。UNIX的核心程序(我们将在第7章中用来分析命令行上的数据)是模块化的，并且设计为与其他程序很好地配合使用。Unix哲学的模块化方法在生物信息学中有许多优势：
1.	使用模块化工作流，可以更容易地发现错误并找出错误发生的位置。在模块化工作流中，每个组件都是独立的，这使得检查中间结果是否不一致和隔离有问题的步骤变得更加容易。相反，大型的非模块化程序隐藏了潜在的问题(您所看到的只是它的最终输出数据)，并且使得定位问题产生的地方变得困难。
2.	模块化工作流使我们能够试验其他方法和方法，因为单独的组件可以很容易地与其他组件互换。例如，如果您怀疑某个特定的校准器对您的数据的处理效果不佳，那么很容易将这个校准器换成另一个校准器。这只有在模块化工作流中才有可能，其中我们的比对程序与下游步骤如变体调用或RNA-seq分析分开。
3.	模块化组件允许我们选择适合特定任务的工具和语言。这是Unix环境非常适合生物信息学的另一个原因：它允许我们组合命令行工具来交互地探索数据(在第7章中将更深入地讨论)，Python用于更复杂的脚本编写，R用于统计分析。当程序被设计为与其他程序一起工作时，为特定任务选择专门的工具是没有成本的-这是我们在生物信息学中经常做的事情。
4.	模块化程序是可重用的，适用于多种类型的数据。编写良好的模块化程序可以重新组合并应用于不同的问题和数据集，因为它们是独立的部分。最重要的是，通过重新混合模块化组件，可以用现有的工具解决新的问题。
        
&emsp;&emsp;除了强调程序的模块化和接口，McIlroy的引用还提到了文本流。我们将在本章中讨论Unix流，但是流的概念在我们如何处理大型数据时非常重要。大数据的定义可能会有所不同，虽然单通道测序数据对于一个刚进入测序的实验室来说可能很大，但与较大的测序中心每小时处理的数据相比，这是微不足道的。无论如何，排序数据的通道太大，无法放入大多数标准台式机的内存中。如果我需要在这个数据中搜索确切的字符串“GTGATTAACTGCGAA”，我无法在记事本中打开一条数据通道并使用查找功能来确定它发生的位置-根本没有足够的内存来在内存中保存所有这些核苷酸。相反，工具必须依赖数据流，从源中读取并主动处理。通用Unix工具和许多生物信息学程序都设计为通过流获取输入，并通过不同的流传递输出。正是这些文本流允许我们将程序耦合到工作流中并处理数据，而无需将大量数据存储在计算机的内存中。

!['suggestion'](../img/suggestion.png)各种类型的Unix shell命令

    在本书中，我将经常提到的不仅仅是单一的unix shell命令。Shell是计算机程序，许多程序员设计并实现了他们自己的版本。这许多版本可能会给新用户带来令人沮丧的问题，因为一些shell的功能与其他shell不兼容。
    为了避免这种问题，请确保您使用的是Bourne-Again shell或bash。Bash应用较为广泛，是苹果OS X和Ubuntu Linux等操作系统上的默认shell。您可以运行echo$shell来验证您是否正在使用bash作为shell(最好也检查echo$0表示的内容，因为即使您确定使用哪种shell，如何识别shell也是不同的！)。我不推荐其他shell，如C shell(Csh)、其后代tcsh和Korn shell(Ksh)，因为这些在生物信息学中不太流行，可能与本书中的示例不兼容。Bourne shell(Sh)是Bourne-Again shell(Bash)的前身；但是bash更新，通常更受欢迎。
    可以使用chsh命令更改shell。在我的日常生物信息学工作中，我使用Z shell(Zsh)，并将其作为我的默认shell。Z shell有很多先进的功能(例如，更好的自动运行功能)，在生物信息学中应用较为广泛。除非另有说明，否则本书中的所有内容均是以这两个shell为主。如果你对一般的shell基本知识有信心，你可能想试试Z shell。我已经在GitHub上本章的README文件中包含了关于Z shell的资源。

&emsp;&emsp;关于Unix shell的最后一点要强调的是它难以置信的强大。有了通配符等简单功能，将命令应用于数百个文件就变得轻而易举了。但是这种能力也带来了风险：Unix shell不关心命令是否输入错误或者它们是否会销毁文件；Unix shell不是为了防止你做不安全的事情而设计的。加里·伯恩哈特(Gary Bernhardt)打了一个很好的比喻：Unix就像一把电锯。电锯是强大的工具，使许多困难的任务，如切割厚厚的原木相当容易。不幸的是，这种力量伴随着危险：电锯可以很容易地穿过你的腿(嗯，技术上更容易)。例如，考虑：

```shell
$ rm -rf tmp-data/aligned-reads* # deletes all old large files
$ # versus
$ rm -rf tmp-data/aligned-reads * # deletes your entire current directory
rm: tmp-data/aligned-reads: No such file or directory
```

&emsp;&emsp;在Unix中，一个空格可能意味着清理一些旧文件和延迟完成项目之间的区别，因为您不小心删除了所有内容。这是使用强大工具的结果，不应该引起恐慌。相反，在试验或尝试新命令时只需采取谨慎的态度(例如，在临时目录中工作，如果不确定命令的行为，则使用假文件或数据，并始终保留备份)。Unix shell设计的一个重要部分就是，有能力让你做很强大的(可能不安全的)操作：
 
>Unix was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things.
—Doug Gwyn
       
&emsp;&emsp;高级生物信息学家必备技能之一是以聪明的方式处理重复的大型数据处理任务。而shell通常是完成这些任务最快的工具。在本章中，我们将重点介绍一些Unix shell基础概念，这些基础概念可以帮助我们从简单的部分构建复杂的程序：流、重定向、管道、使用进程和命令替换。nix shell的另一个重要部分是多关于自动化任务的知识，我们将在第12章学习更多这方面的内容。

### 使用流和重定向

&emsp;&emsp;生物信息学数据通常是文本，例如，测序读取文件或参考基因组中的AS、Cs、Ts和Gs或基因坐标的制表符分隔文件。生物信息学中的文本数据通常也很大(千兆字节或超过计算机内存的数据)。这就是为什么Unix处理文本流的哲学在生物信息学中是有用的：文本流允许我们对数据流进行处理，而不是将其全部保存在内存中。
     
&emsp;&emsp;例如，假设我们在一个FASTA文件中有两个充满核苷酸序列的大文件，这是一种用于存储序列数据的标准文本格式(通常是DNA，但偶尔也是蛋白质)。即使是将这两个大文件合并为一个文件的简单任务，一旦这些文件的大小达到几千兆字节，也会变得很棘手。在不使用Unix shell的情况下，如何完成这个简单的任务？您可以尝试打开一个文件，选择并复制其所有内容，然后将其粘贴到另一个文件中。然而，这不仅需要将两个文件加载到内存中，而且在选择“全部”、“复制”和“粘贴”时，还需要使用额外的内存来制作一个文件的另一个副本。像这样的方法不能扩展到我们在生物信息学中经常使用的数据的大小。此外，将内容粘贴到文件中并不遵循第1章：将数据视为只读的建议。如果出现错误，其中一个文件(或两个文件！)很容易损坏。更糟糕的是，复制和粘贴大文件会占用大量内存，因此您的计算机更有可能出现问题。Streams为这些问题提供了可伸缩的、健壮的解决方案。

### 将标准输出重定向到文件

&emsp;&emsp;Unix shell通过利用流简化了组合大型文件等任务。使用流可以防止我们将不必要地大文件加载到内存中。相反，我们可以通过将大文件的内容打印到标准输出流来组合大文件，并将此流从终端重定向到我们希望保存组合结果的文件中。您可能已经使用程序cat将文件的内容打印到标准输出(当不重定向时将打印到您的终端屏幕)。例如，我们可以使用cat将tb1-protein.fasta文件(可在本章GitHub上的目录中找到)打印到标准输出：

```shell
$ cat tb1-protein.fasta&gt;teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
```

&emsp;&emsp;cat还允许我们按照它们在命令参数中出现的顺序，将多个文件的内容打印到标准输出流中。这实质上连接了这些文件，如这里所示，与tb1和tga1翻译的序列：

```shell
$ cat tb1-protein.fasta tga1-protein.fasta&gt;teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
>teosinte-glume-architecture-1 protein
DSDCALSLLSAPANSSGIDVSRMVRPTEHVPMAQQPVVPGLQFGSASWFP
RPQASTGGSFVPSCPAAVEGEQQLNAVLGPNDSEVSMNYGGMFHVGGGSG
GGEGSSDGGT
```
&emsp;&emsp;虽然这些文件已经连接，但结果不会保存在任何地方-这些行只是打印到终端屏幕上。为了将这些连接的结果保存到文件中，您需要将这个标准输出流从终端屏幕重定向到一个文件。重定向是Unix中的一个重要概念，也是您在生物信息学中经常使用的一个概念。
&emsp;&emsp;我们使用运算符>或>>将标准输出重定向到文件。运算符>将标准输出重定向到文件并覆盖该文件的任何现有内容(请注意并小心使用者一点)，而后一个运算符>>则讲内容附加到文件中(保留内容并仅添加到末尾)。如果该文件不存在，两个操作符都会在将输出重定向到它之前创建该文件。为了连接我们的两个FASTA文件，我们像之前那样使用cat，但将输出重定向到一个文件：
```shell
$ cat tb1-protein.fasta tga1-protein.fasta > zea-proteins.fasta
```
&emsp;&emsp;请注意，当您将标准输出重定向到文件时，不会将任何内容打印到终端屏幕上。在我们的示例中，整个标准输出流最终位于zea-proteins.fasta文件中。将标准输出流重定向到文件，如图3-1(B)所示。

图3-1、(a)未重定向的标准输出、标准错误和标准输入(灰框是打印到用户终端的内容)；(b)重定向到文件的标准输出。
       
&emsp;&emsp;我们可以通过检查此目录中最新创建的文件是否是我们刚刚创建的文件(即zea-proteins.fasta)来验证我们的重定向工作是否正确：
```shell 
ls -lrttotal 24
-rw-r--r-- 1 vinceb staff 353 Jan 20 21:24 tb1-protein.fasta
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tga1-protein.fasta
-rw-r--r-- 1 vinceb staff 505 Jan 20 21:35 zea-proteins.fasta
```
&emsp;&emsp;将-lrt添加到ls中以列表格式(-l)、反向(-r)、时间(-t)顺序列出此目录中的文件(更多详细信息，请参见man ls)。另外，请注意这些标志是如何组合到-lrt中的；这是一种常见的语法快捷方式。如果希望在顶部看到最新的文件，可以省略r标志。

### 重定向标准错误

&emsp;&emsp;由于许多程序使用标准输出流来输出数据，因此需要单独的流来处理错误、警告和要由用户读取的消息。标准错误是仅用于此目的流(如图3-1所示)。与标准输出一样，默认情况下，标准错误直接发送到您的终端。在实践中，我们经常希望将标准错误流重定向到文件，以便将消息、错误和警告记录到稍后可以检查的文件中。
       
&emsp;&emsp;为了说明如何重定向标准输出和标准错误，我们将使用命令ls-l列出一个现有文件(tb1.fast a)和一个不存在的文件(foly1.fast a)。现有文件tb1.fast a的ls-l的输出将被发送到标准输出，而一条错误消息，说明foly1.fasta不存在，将被输出到标准错误。当您不重定向任何内容时，两个流都会输出到您的终端：
```shell
$ ls -l tb1.fasta leafy1.fastals: leafy1.fasta: No such file or directory
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:58 tb1.fasta
```
&emsp;&emsp;要将每个流重定向到单独的文件，我们将上一节中的>运算符与用于重定向标准错误流2>的新运算符相结合：
```shell
$ ls -l tb1.fasta leafy1.fasta &gt; listing.txt 2&gt; listing.stderr$ cat listing.txt
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tb1.fasta
$ cat listing.stderr
ls: leafy1.fasta: No such file or directory
```
&emsp;&emsp;此外，2>具有2>>这类似于>>(它将附加到文件而不是覆盖它)。

!['suggestion'](../img/suggestion.png)文件描述符

       2表示法可能看起来很神秘(并且很难记忆)，但是标准错误的重定向操作符中包含2是有原因的。Unix系统上的所有打开文件(包括流)都被分配一个称为文件描述符的唯一整数。UNIX的三个标准流-标准输入(稍后将看到)、标准输出和标准错误-分别被赋予文件描述符0、1和2。甚至可以使用1作为标准输出的重定向运算符，尽管这在实践中并不常见，可能会使合作者感到困惑。
       
       偶尔，一个程序会产生我们不需要或不关心的消息。重定向是一种有用的方法，可以静默一些程序写入标准输出的诊断信息：我们只需重定向到stderr.txt这样的日志文件。然而，在某些情况下，我们不需要将此输出保存到文件中，将输出写入物理磁盘可能会降低程序的速度。幸运的是，类Unix操作系统有一个特殊的“伪”磁盘(称为伪设备)，可以将不需要的输出重定向到：/dev/null。写入/dev/null的输出会消失，这就是为什么它有时被书呆子们戏称为“黑洞”的原因。

!['suggestion'](../img/suggestion.png)使用tail-f监控重定向标准错误

    对于可能运行数天(或可能数周，或数月！)的大型生物信息学程序，我们经常需要重定向标准输出和标准错误。重定向这两个流后，不会将任何内容打印到您的终端，包括您可能希望在长时间运行的任务期间监视的有用诊断消息。如果希望遵循这些消息，可以使用程序tail通过调用tail filename.txt来查看输出文件的最后几行。例如，运行tail stderr.txt将打印文件stderr.txt的最后10行。您可以使用-n选项设置tail将打印的确切行数。
       
    tail还可以用来不断监视带有-f的文件(后面是-f)。随着被监控文件的更新，Tail将在您的终端屏幕上显示新行，而不是像没有此选项那样只显示10行并退出。如果希望停止对文件的监视，可以使用Control-C中断尾部进程。当您关闭Tail时，写入文件的进程不会被中断。

### 使用标准输入重定向

&emsp;&emsp;Unix shell还为标准输入提供了重定向运算符。通常标准输入来自键盘，但使用<重定向操作符，您可以直接从文件中读取标准输入。虽然标准输入重定向不如>、>>和2>常见，但它偶尔还是有用的：

```shell
$ program < inputfile > outputfile
```

&emsp;&emsp;在这个例子中，人工文件inputfile通过标准输入提供给程序，并且程序的所有标准输出都被重定向到文件outputfile。
使用Unix管道(例如cat inputfile|program>output file)比使用<更常见一些。我们稍后将看到的许多程序(如grep、awk、sort)除了通过标准输入进行输入外，还可以接受文件参数。其他程序(特别是在生物信息学中常见)使用单个破折号参数(-)来指示它们应该使用标准输入，但这是一个约定，而不是Unix的一个功能。

&emsp;&emsp;万能的Unix管道：速度与效率合二为一

>We should have some ways of connecting programs like [a] garden hose—screw in
another segment when it becomes necessary to massage data in another way.
—Doug McIlory (1964)

&emsp;&emsp;在第37页McIlroy的引用“为什么我们在生物信息学中使用Unix？模块化和Unix哲学“包括了相关建议，”写程序一起工作“。这要归功于Unix管道，这是McIlroy自己发明的一个概念。UNIX管道与我们之前看到的重定向操作符类似，不同之处在于管道将程序的标准输出流重定向到文件，而不是将其重定向到另一个程序的标准输入。只有标准输出通过管道传输到下一个命令；标准错误仍然打印到终端屏幕，如图3-2所示。
图3-2、通过管道将标准输出从Program1传输到Program2；标准错误仍然打印到用户的终端

&emsp;&emsp;您可能想知道为什么我们将一个程序的标准输出直接重定向到另一个程序的标准输入中，而不是将输出写入一个文件，然后将这个文件读入下一个程序。在许多情况下，创建文件将有助于检查中间结果并且可以调试工作流的步骤-那么为什么不能每次都这样做呢？
       
&emsp;&emsp;答案是，它通常归结为计算效率-读取和写入磁盘非常慢。我们在生物信息学中使用管道(相当强制)，不仅因为它们是构建管道的有用方式，而且因为它们更快(在某些情况下，更快得多)。现代磁盘比内存慢几个数量级。现代磁盘比内存慢几个数量级。例如，从内存读取1兆字节的数据只需要大约15微秒，但是从磁盘读取1兆字节的数据需要2毫秒。这2毫秒是2，000微秒，使得从磁盘读取的速度慢了100多倍(这是一个估计值；实际数字将根据您的磁盘类型和速度而变化)。
       
&emsp;&emsp;在实践中，从磁盘写入或读取(例如，在将标准输出重定向到文件期间)通常是数据处理中的瓶颈。对于下一代大型测序数据，这可能会大大减慢速度。如果您实现了一个比旧版本快两倍的聪明算法，那么如果真正的瓶颈是读取或写入磁盘，您甚至可能没有注意到差异。此外，不必要地将输出重定向到文件会占用磁盘空间。对于下一代大型数据和潜在的许多实验样本，这可能是一个相当大的问题。
       
&emsp;&emsp;通过管道将一个程序的输出直接传递到另一个程序的输入中，是一种计算高效且简单的Unix程序接口方式。这是生物信息学家(以及一般的软件工程师)喜欢Unix的另一个原因。管道允许我们从较小的模块部分构建更大、更复杂的工具。用什么语言编写程序也无关紧要；只要两个程序都理解它们之间传递的数据，管道就可以在任何东西之间工作。作为大多数程序之间最低的公分母，经常使用纯文本流-这是McIlroy在他关于Unix哲学的引用中提出的观点。

### 执行管道：使用grep和Pipes创建简单程序
       
&emsp;&emsp;生物信息学的黄金法则是不要相信你的工具或数据。这种怀疑论要求对中间结果进行持续的健全检查，以确保您的方法不会使数据产生偏差，或者数据中的问题不会因您的方法而加剧。然而，编写定制脚本来检查中间数据的每一位可能会很昂贵，即使您是一个快速的程序员，可以在第一次编写没有bug的代码。UNIX管道允许我们快速且迭代地构建微小的命令行程序来检查和操作数据-我们将在第7章中更深入地探讨这种方法。管道还广泛用于更大的生物信息学工作流(第12章)，因为它们避免了将不必要的文件写入磁盘的延迟问题。我们将在本节中学习管道的基础知识，准备在本书的其余部分中使用它们。
       
&emsp;&emsp;让我们看看如何使用管道将进程链接在一起。假设我们正在使用一个FASTA文件，并且一个程序警告它在序列中包含非核苷酸字符。你会对此感到惊讶，因为序列只是DNA。我们可以使用管道和grep的Unix单行代码轻松地检查非核苷酸字符。grep unix工具在文件或标准输入中搜索匹配模式的字符串。这些模式可以是简单的字符串，也可以是正则表达式(实际上有两种类型的正则表达式，基本表达式和扩展表达式；有关更多详细信息，请参见man grep)。如果您不熟悉正则表达式，请参阅该书的GitHub存储库的Readme中的参考资料。
       
&emsp;&emsp;我们的管道将首先从FASTA文件中删除所有标题行(以>开头的行)，因为我们只关心序列是否具有非核苷酸字符。然后，可以将FASTA文件的其余序列通过管道传输到grep的另一个实例，该实例只打印包含非核苷酸字符的行。为了使这些字符在我们的终端中更容易识别，我们还可以为这些匹配的字符上色。整个命令将如下所示：

```shell
$ grep -v "^>" tb1.fasta | \    (1)
 grep --color -i "[^ATCG]"      (2)
CCCCAAAGACGGACCAATCCAGCAGCTTCTACTGCTAYCCATGCTCCCCTCCCTTCGCCGCCGCCGACGC
```

(1)首先，我们删除以>字符开头的FASTA标题行。我们的正则表达式模式是^>，它匹配以>字符开头的所有行。插入符号在正则表达式中有两种含义，但在此上下文中，它用于将模式锚定到行首。因为我们想要排除以>开头的行，所以我们使用grep选项-v反转匹配的行。最后，我们使用管道字符(|)将标准输出通过管道传输到下一个命令。反斜杠(\)字符只是表示我们将在下一行继续执行命令，上面使用该字符是为了提高可读性。

(2)其次，我们希望找到不是A、T、C或G的任何字符。最容易构造与A、T、C或G不匹配的正则表达式模式。为此，我们在正则表达式中使用插入符号的第二个含义。在括号中使用时，插入符号匹配不是这些括号中的字符之一的任何字符。因此，模式[^ATCG]匹配任何不是A、T、C或G的字符。此外，我们忽略-i的大小写，因为a、t、c和g是有效的核苷酸(小写字符通常用于表示屏蔽重复或低复杂性序列)。最后，我们添加grep的-color选项来为匹配的非核苷酸字符着色。

&emsp;&emsp;在终端窗口中运行时，这将突出显示“Y”。有趣的是，根据IUPAC设定的标准，Y实际上是有效的扩展二义性核苷酸编码。Y表示嘧啶碱基：C或T。其他单字母IUPAC代码可以表示序列数据中的不确定性。例如，嘌呤碱基由R表示，而A、G或T的碱基具有代码D。
      
&emsp;&emsp;让我们讨论一下关于这个简单的Unix管道的几个附加问题。首先，注意两个正则表达式都用引号引起来，这是一个很好的习惯。此外，如果我们使用grep-v tb1.fasta，您的shell会将>解释为重定向运算符，而不是提供给grep的模式。不幸的是，这会错误地覆盖您的tb1.fasta文件！大多数生物信息学家在某种程度上都犯过这个错误，并从中吸取了教训(通过丢失他们希望grep的Fasta文件)，所以要小心。
      
&emsp;&emsp;这个简单的Unix单行代码编写和运行只需要几秒钟，非常适合这个特定的任务。我们可以编写一个更复杂的程序，显式地解析FASTA格式，计算出现的次数，并输出带有非核苷酸字符的序列名称列表。然而，对于我们的任务-查看程序为什么不工作-动态构建简单的命令行工具是快速和足够的。在第7章中，我们将看到更多如何使用Unix数据程序和管道构建命令行工具的示例。

### 管道和重定向组合使用

&emsp;&emsp;像校准器、汇编器和SNP调用器这样的大型生物信息学程序通常会同时使用多个流。通过标准输出流输出结果(例如，对齐的读数、组装的重叠群或SNP调用)，同时将诊断消息、警告或错误输出到标准错误流。在这种情况下，我们需要结合管道和重定向来管理来自正在运行的程序的所有流。
      
&emsp;&emsp;例如，假设我们有两个假想的程序：Program1和Program2。我们的第一个程序Program1对名为input.txt的输入文件进行一些处理，并将结果输出到标准输出流，并将诊断消息输出到标准错误流。我们的第二个程序Program2将Program1的标准输出作为输入并对其进行处理。program 2还将自己的诊断消息输出到标准错误，并将结果输出到标准输出。棘手的部分是我们现在有两个输出到标准错误和标准输出的过程。如果我们没有同时捕获Program1和Program2的标准错误流，我们的屏幕上就会出现一堆乱七八糟的诊断信息，滚动得太快以至于我们无法阅读。幸运的是，我们可以轻松地组合管道和重定向：

```shell     
$ program1 input.txt 2>program1.stderr | \   (1) program2 2> program2.stderr >results.txt    (2)
```
(1)program 1处理input.txt输入文件，然后将其结果输出到标准输出。Program1的标准错误流重定向到Program1.stderr日志文件。和以前一样，反斜杠用于将这些命令分成多行，以提高可读性(在您自己的工作中是可选的)。

(2)同时，program 2使用program 1的标准输出作为其标准输入。shell将Program2的标准错误流重定向到Program2.stderr日志文件，并将Program2的标准输出重定向到Results.txt。

&emsp;&emsp;有时，我们需要将标准错误流重定向到标准输出。例如，假设我们想使用grep在program 1的标准输出和标准错误流中搜索“error”。使用管道不起作用，因为管道只将一个程序的标准输出链接到下一个程序的标准输入。管道忽略标准错误。我们可以通过首先将标准错误重定向到标准输出，然后通过管道将这个合并的流传输到grep来解决这个问题：
```shell
$ program1 2>&1 | grep "error"
```
     
&emsp;&emsp;2>&1运算符将标准错误重定向到标准输出流
 
## 多个重定向：管道中的T形三通
       
&emsp;&emsp;如前所述，管道通过将一个进程的标准输出连接到另一个进程的标准输入来防止不必要的磁盘写入和读取操作。但是，我们有时确实需要在Unix管道中将中间文件写入磁盘。这些中间文件在调试管道或希望为需要很长时间才能完成的步骤存储中间文件时非常有用。就像水管工的T型接头一样，Unix程序树将管道的标准输出流的副本转移到中间文件，同时仍然通过其标准输出传递它：
```shell
$ program1 input.txt | tee intermediate-file.txt | program2 > results.txt
```
      
&emsp;&emsp;在这里，program 1的标准输出既被写入intermediate-fle.txt，又直接通过管道传输到program 2的标准输入中。
 
## 管理流程并与其交互
       
&emsp;&emsp;当我们通过Unix shell运行程序时，它们成为进程，直到它们成功完成或因错误而终止。有多个进程同时在您的机器上运行-例如，系统进程，以及您的Web浏览器、电子邮件应用程序、生物信息学程序等。在生物信息学中，我们经常使用运行了大量时间的进程，因此我们知道如何使用和管理Unix shell中的进程非常重要。在本节中，我们将学习操作进程的基础知识：在后台运行和管理进程，终止错误的进程，以及检查进程退出状态。
 
## 后台进程
       
&emsp;&emsp;当我们在shell中键入命令并按Enter时，无论命令运行多长时间，我们都无法访问该shell提示符。这对于短期任务来说是很好的，但是在shell中继续工作之前等待长时间运行的生物信息学程序完成将会扼杀我们的生产力。shell还提供了在后台运行程序的选项，而不是在前台运行程序(就像运行命令时通常所做的那样)。在后台运行进程将释放提示，以便您可以继续工作。
       
&emsp;&emsp;我们可以通过在命令的末尾附加&号来告诉Unix shell在后台运行程序。例如：

```shell      
$ program1 input.txt > results.txt &[1] 26577
```
         
&emsp;&emsp;shell返回的数字是program 1的进程ID或PID。这是一个唯一的ID，允许您稍后识别和检查Program1的状态。我们可以检查我们有哪些进程在后台运行作业：
```shell
$ jobs[1]+ Running program1 input.txt > results.txt
```
      
&emsp;&emsp;要将后台进程再次带入前台，我们可以使用fg(表示前景)。FG将把最新的进程带到前台。如果有许多进程在后台运行，它们都将出现在程序作业的列表输出中。像[1]这样的数字是作业ID(与系统分配给正在运行的程序的进程ID不同)。要将特定的后台作业返回到前台，请使用fg%<num>，其中<num>是其在作业列表中的编号。如果我们想将Program1返回到前台，fg和fg%1都会做同样的事情，因为只有一个后台进程：
```shell
$ fgprogram1 input.txt &gt; results.txt
```
​​
![warning](../img/warning.png)后台进程和终止信号
      
    对于后台进程有一个小问题：虽然它们在后台运行并且似乎与我们的终端断开连接，但是关闭我们的终端窗口会导致这些进程被终止。不幸的是，许多长期运行的重要进程都是以这种意外地方式被终止的。
       
    每当我们的终端窗口关闭时，它就会发出挂断信号。挂机信号(也称为SIGHUP)来自网络连接可靠性大大降低的时代。断开的连接可能会阻止用户停止异常的、资源匮乏的进程。为了解决这个问题，将挂起信号发送到从关闭的终端开始的所有进程。几乎所有的Unix命令行程序一收到这个信号就停止运行。
        
    所以要小心-在后台运行一个进程并不能保证它在终端关闭时不会死掉。为了防止出现这种情况，我们需要使用工具nohup或在Tmux中运行它，这两个主题我们将在第4章中进行更详细的讨论。
        
&emsp;&emsp;也可以将已经在前台运行的进程放入后台。为此，我们首先需要挂起进程，然后使用bg命令在后台运行它。挂起一个进程会暂时暂停它，允许您将它放在后台。我们可以通过组合键Control-z发送停止信号来挂起进程。使用我们想象中的程序1，我们将按如下方式完成此任务：

```shell       
$ program1 input.txt > results.txt # forgot to append ampersand$ # enter control-z
[1]+ Stopped program1 input.txt &gt; results.txt
$ bg
[1]+ program1 input.txt > results.txt
```      
&emsp;&emsp;与前面的fg一样，我们也可以使用job来查看挂起的进程的作业ID。如果我们有多个正在运行的进程，我们可以使用bg%<num>指定哪个进程移到后台(其中<；num>是作业ID)。
 
## 终止进程
      
&emsp;&emsp;有时我们需要终止一个进程。对于一个进程来说，要求我们的计算机资源过多或变得无响应，需要我们发送一个特殊的信号来终止进程，这并不少见。终止一个进程将永远结束它，不像用停止信号挂起它，它是不可恢复的。如果进程当前正在shell中运行，则可以通过输入Control-C来终止它。这仅在此进程在前台运行时有效，因此如果它在后台运行，则必须使用前面讨论的fg。
      
&emsp;&emsp;更高级的进程管理(包括使用top和ps监视和查找进程，以及使用kill命令终止进程)超出了本章的范围。然而，在本章关于GitHub的[README]()文件中有很多关于流程和资源管理的信息。
 
## 退出状态：如何以编程方式判断您的命令是否有效
      
&emsp;&emsp;长时间运行的流程的一个问题是，您可能不会监视等待它们。你怎么知道他们什么时候完成？你怎么知道他们是否没有错误成功地完成了？UNIX程序退出时具有退出状态，这表明程序终止时没有问题或有错误。根据Unix标准，退出状态为0表示进程运行成功，任何非零状态表示发生了某种错误(希望程序也打印一条可理解的错误消息)。

      ​​
![warning](../img/warning.png)警告退出状态

        不幸的是，程序在遇到错误时是否返回非零状态取决于程序开发人员。偶尔，程序员会忘记很好地处理错误(在生物信息学程序中确实会发生这种情况)，程序可能会出错，但仍然返回零退出状态。这也是为什么遵循黄金法则(即，不要相信你的工具)和总是检查你的中间数据至关重要的另一个原因。
        
&emsp;&emsp;退出状态不会打印到终端，但shell会将其值设置为shell中名为$？的变量(恰当地命名为shell变量)。我们可以在运行命令后使用echo命令查看此变量的值：
```shell
$ program1 input.txt > results.txt$ echo $?
0
```
      
&emsp;&emsp;退出状态非常有用，因为它们允许我们以编程方式在shell中将命令链接在一起。链中的后续命令根据最后一个命令的退出状态有条件地运行。shell提供了两个实现此功能的运算符：一个运算符仅在第一个命令成功完成(&&)时运行后续命令，另一个运算符仅在第一个命令未成功完成(||)时运行下一个命令。如果你熟悉短路评估的概念，你就会明白这些运算符分别是并和或。
      
&emsp;&emsp;最好在示例中查看这些运算符。假设我们想运行Program1，让它将其输出写入文件，然后让Program2读取此输出。为了避免因为Program1因错误而终止，Program2读取不完整的问题文件，我们希望仅在Program1返回零(成功)退出代码后才启动Program2。仅当以前的命令以非零退出状态完成时，shell运算符&&才执行后续命令：
```shell
$ program1 input.txt > intermediate-results.txt && \ program2 intermediate-results.txt >results.txt
```
      
&emsp;&emsp;使用|运算符，只有在前一个命令失败(以非零状态退出)时，才能让shell执行命令。这对于警告消息很有用：
```shell
$ program1 input.txt > intermediate-results.txt || \ echo "warning: an error occurred"
```
      
&emsp;&emsp;如果要测试&&和||，有两个Unix命令，它们只返回退出成功(True)或退出失败(False)。例如，考虑一下为什么打印以下行：
```shell
$ true$ echo $?
0
$ false
$ echo $?
1
$ true && echo "first command was a success"
first command was a success
$ true || echo "first command was not a success"
$ false || echo "first command was not a success"
first command was not a success
$ false && echo "first command was a success"
```
     
&emsp;&emsp;此外，如果您不关心退出状态，只希望顺序执行两个命令，则可以使用单个分号(；)：
```shell    
$ false; true; false; echo "none of the previous mattered"none of the previous mattered
```
      
&emsp;&emsp;如果您只知道shell是通过终端与之交互的东西，那么您可能会开始注意到它具有完整编程语言的许多元素。这是因为它是！事实上，您可以编写和执行shell脚本，就像编写和执行Python脚本一样。让你的生物信息学shell工作在一个版本控制下的注释shell脚本中是确保你的工作是可重现的最好方法。我们将在第12章讨论shell脚本。
 
## 命令替换
      
&emsp;&emsp;UNIX用户喜欢让Unix shell为他们工作-这就是为什么存在像通配符和花括号扩展这样的shell扩展(如果您需要复习，请参阅第2章)。另一种有用的shell扩展是命令替换。命令替换以内联方式运行Unix命令，并将输出作为可在其他命令中使用的字符串返回。这就提供了许多有用的可能性。
      
&emsp;&emsp;在新年的早期，我们还没有适应使用新的日期，这是一个很好的例子，说明了这一点是有用的。例如，进入2013年后的五天，我与我的合作者分享了一个名为snp-sim-01-05-2012(mmdd-yyyy格式)的新结果目录。尴尬平息后，Unix解决方案出现了：date命令以编程方式将当前日期作为字符串返回。我们可以使用这个字符串自动给出包含当前日期的目录名。我们使用命令替换来运行Date程序，并用它的输出(字符串)替换这个命令。通过一个更简单的例子，这更容易理解：

```shell     
$ grep -c '^>' input.fasta     (1)416
$ echo "There are $(grep -c '^>' input.fasta) entries in my FASTA file."   (2)
There are 416 entries in my FASTA file.
```
(1)这个命令使用grep来计算与模式匹配的行数(-c选项代表count)。在本例中，我们的模式^>匹配FASTA标题行。因为每个FASTA文件条目都有一个以“>”开头的标题“>sequence-a”，所以这个命令匹配这些标题中的每一个并计算FASTA条目的数量。

(2)现在假设我们想要获取grep命令的输出并将其插入到另一个命令中-这就是命令替换的意义所在。在这种情况下，我们希望echo打印一条消息，其中包含有多少个FASTA条目到标准输出。使用命令替换，我们可以计算并将FASTA条目的数量直接返回到这个字符串中！

&emsp;&emsp;使用这种命令替换方法，我们可以使用date +%F命令轻松地创建日期目录，其中参数+%F只是告诉date程序以特定格式输出日期。日期有多种格式选项，因此您的欧洲同事可以将日期指定为“19 May 2011”，而您的美国同事可以指定“May 19, 2011：”

```shell
$ mkdir results-$(date +%F)$ ls results-2015-04-13
```
       
&emsp;&emsp;通常，date +%F返回的格式对于日期目录来说是一种非常好的格式，因为当结果按名称排序时，这种格式的目录也会按时间顺序排序：

```shell      
$ ls -ldrwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 1999-07-01
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2000-12-19
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2011-02-03
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2012-02-13
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 2012-05-26
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2012-05-27
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 2012-07-04
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 2012-07-05
```
&emsp;&emsp;这背后的聪明之处就是使得这种日期格式(即ISO 8601)非常有用。

!['suggestion'](../img/suggestion.png)Unix存储技巧

    在第2章中，我们使用mkdir-p和brace展开创建了一个项目目录。如果您发现自己经常制作相同的项目结构，那么值得将其存储起来，而不是每次都打印出来。为什么要多次重复？
      
    早期的Unix用户是一群聪明(或懒惰)的人，他们设计了一个工具来存储重复的命令组合：别名。如果您一遍又一遍地运行一个聪明的一行程序，可以使用add alias将其添加到~/.bashrc(如果在OSX上，则使用~/.Profle)。别名只是将命令别名为较短的别名。例如，如果您总是使用相同的目录结构创建项目目录，请添加如下所示的行：
```shell
alias mkpr="mkdir -p {data/seqs,scripts,analysis}"
```       
&emsp;&emsp;对于像这样的小东西，编写更复杂的脚本是没有意义的；采用Unix方式并保持简单。另一个例子是，我们可以将date+%F命令别名为今天：
```shell
alias today="date +%F"
```
       
&emsp;&emsp;现在，输入mkdir results-$(today)将创建一个有日期的结果目录。

&emsp;&emsp;不过，警告一句：不要在项目级shell脚本中使用别名命令！这些文件驻留在Shell的启动文件(例如~/.Profle或~/.bashrc)中，该文件位于项目目录之外。如果分发项目目录，则任何需要别名定义的shell程序都将无法工作。在计算领域，我们说这样的做法是不可移植的-如果它离开你的系统，它就会崩溃。编写可移植的代码，即使它不会在其他地方运行，也将有助于保持项目的可重复性。
       
&emsp;&emsp;像所有好东西一样，像命令替换这样的Unix技巧最好适度使用。一旦你对这些技巧有了更多的熟悉，它们就会非常快速和简单地解决日常烦恼。但是，一般来说，最好保持简单，并且知道何时使用快速的Unix解决方案，以及何时使用其他工具，如Python或R。我们将在第7章和第8章中更深入地讨论这一点。