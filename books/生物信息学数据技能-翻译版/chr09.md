## 第九章、使用范围数据

>Here is a problem related to yours and solved before. Could you use it? Could you use
its result? Could you use its method?
— How to Solve It George Pólya (1945)

&emsp;&emsp;对于生物信息学家来说幸运的是，来自地球上生命的每个分支的每个基因组都由染色体序列组成，这些染色体序列可以用同样的方式在计算机上表示：作为一组核苷酸序列(基因组变异和组装不确定性除外)。每个单独的序列代表一个参考DNA分子，它可能对应于完全组装的染色体，或者部分组装的基因组中的支架或重叠群。虽然核苷酸序列是线性的，但它们也可能代表被切割的生物圆形染色体(例如，带有质粒或线粒体)。除了包含核苷酸序列(生命的As，Ts，Cs和Gs)外，这些参考序列还充当我们描述基因组中一切事物位置的坐标系。此外，因为这些染色体序列的单位是单独的碱基对，所以没有更好的分辨率可以用来指定基因组上的位置。

&emsp;&emsp;使用这个坐标系，我们可以将基因组上的位置或区域描述为线性染色体序列上的范围。为什么这很重要？许多类型的基因组数据被链接到特定的基因组区域，并且该区域可以表示为包含染色体上连续位置的范围。注释数据和基因组特征(如基因模型)、遗传变体(如SNPs和插入/缺失)、转座元件、结合位点以及统计数据(如成对多样性和GC含量)都可以表示为线性染色体序列上的范围。由全基因组重测序、RNA序列、芯片序列和亚硫酸氢盐测序等实验产生的序列读取比对数据也可以表示为范围。

&emsp;&emsp;一旦我们的基因组数据被表示为染色体上的范围，就有许多范围操作可供我们处理，以处理查找和计数重叠、计算覆盖范围、查找最近的范围以及从特定范围中提取核苷酸序列等任务。一旦我们将数据表示为范围，并将我们的问题重塑为可以用范围操作解决的问题，诸如发现哪些SNP与编码序列重叠，或者计算与外显子重叠的读取比对的数量等特定问题，就会有简单、通用的解决方案。

&emsp;&emsp;正如我们将在本章中看到的，已经有软件库(如R的GenomicRanges)和命令行工具(Bedtools)实现范围操作来解决我们的问题。在幕后，这些实现依赖于像区间树这样的专用数据结构来提供极快的范围操作，这使得它们不仅是解决许多问题的最简单的方法，而且是最快的。

## 基因组范围和坐标系速成课程

&emsp;&emsp;那么范围到底是什么？范围是整数间隔，表示序列(如染色体)上连续位置的子序列。我们使用整数区间，因为碱基对是离散的-我们不能有像50，403，503.53这样的分数基因组位置。范围仅指定沿着单个序列(如染色体)的区域；要指定基因组区域或位置，我们需要三条必要的信息：

*染色体名称*

&emsp;&emsp;这也称为序列名称(以允许未完全组装的序列，如脚手架或重叠群)。每个基因组都由一组染色体序列组成，所以我们需要指定一个范围在哪一个上。更不幸的是，在生物学上没有染色体名称的标准命名方案(这会让你头疼)。染色体名称的例子(以不同的格式)包括'chr17'、 '22'、 'chrX'、'Y' 和'MT'(用于线粒体)，或类似于“HE667775”或“scaffold_1648”的支架。这些染色体名称总是关于某些特定的基因组组装版本，并且可能在不同版本之间有所不同。

*范围*

&emsp;&emsp;例如，114，414，997到114，693，772或3，173，498到3，179，449。范围是我们在染色体序列上指定单个子序列的方式。每个范围由开始位置和结束位置组成。与染色体名称一样，在生物信息学中没有标准的方法来表示一个范围。射程的技术细节是相当重要的，因此我们将在下一步更详细地讨论它们。

*链*

&emsp;&emsp;因为染色体DNA是双链的，特征可以存在于正向(正)或反向(负)链上。染色体上的许多特征是链特异性的。例如，因为蛋白质编码的外显子只有在适当的链上翻译时才有生物学意义，我们需要指定这些特征在哪条链上。

&emsp;&emsp;这三个组成部分构成基因组范围(也称为基因组间隔)。请注意，由于参考基因组是范围的坐标系，因此范围完全链接到特定的基因组版本。换句话说，基因组位置是相对于参考基因组的，所以当使用和谈论范围时，我们需要指定它们相对的基因组版本。

&emsp;&emsp;为了了解线性序列上的范围是什么样子的，图9-1描绘了沿着一条染色体延伸的三个范围。范围x和y彼此重叠(一个碱基对重叠)，而范围z不重叠任何其他范围(并且仅跨越单个碱基对)。范围x和z都在正向DNA链上(注意箭头的方向性)，它们的基础核苷酸序列分别是ACTT和C；范围y在反向链上，其核苷酸序列将是AGCCTTCGA。

!['9-1'](../img/9-1.png)
图9-1。沿着一条染色体延伸的三个范围

<hr>

**基因组版本**

&emsp;&emsp;收集和整理参考基因组是一项持续的工作，而参考基因组是不断变化和改进的。不幸的是，这也意味着我们的坐标系经常在基因组版本之间发生变化，因此像chr15：27，754，876-27，755，076这样的基因组区域将不会在不同的基因组版本之间引用相同的基因组位置。例如，人类基因组版本GRCH38上的这个200bp范围在版本GRCh37/hg19上位于chr15：28，000，022-28，000，222，在版本NCBI36/hg18和NCBI35/hg17上位于chr15：25，673，617-25，673，817，在版本NCBI34/hg16上位于chr15：25，602，381-25，602，581处，在版本NCBI34/hg16上位于chr15：25，602，381-25，602，581！因此，基因组位置总是相对于特定的参考基因组版本。为了可重复性(并使您以后的生活更轻松)，指定您正在使用的参考基因组版本(例如，人类基因组版本GRCH38、Heliconius Melpomene v1.1或Zea Mays AGPv3)是至关重要的。同样重要的是，你和合作者使用相同的基因组版本，这样任何与基因组区域相关的共享数据都是可比较的。

&emsp;&emsp;在某些情况下，您需要将基因组范围数据从旧基因组版本的坐标系重新映射到新版本的坐标系。这将是一项单调乏味的工作，但幸运的是，有成熟的工具可以完成这项任务：

·[CrossMap](http://crossmap.sourceforge.net/)是一种命令行工具，可在不同装配版本的坐标系之间转换多种数据格式(BED、GFF/GTF、SAM/BAM、Wiggle、VCF)。

·[NCBI基因组重新映射服务](https://www.ncbi.nlm.nih.gov/genome/tools/remap)是一个基于网络的工具，支持多种基因组和格式。

·[Liftover](http://genome.ucsc.edu/cgi-bin/hgLiftOver)也是一个基于网络的工具，用于在[UCSC基因组浏览器](http://genome.ucsc.edu/)网站上托管的基因组之间进行转换。

<hr>
     ​​
&emsp;&emsp;尽管表示和处理基因组范围带来了便利，但不幸的是，我们需要注意一些具体的细节。首先，生物信息学数据格式(参见表9-1)和软件程序使用的范围系统有两种不同的风格：

·基于0的坐标系，具有半闭合、半开间隔。

·基于1的坐标系，具有闭合间隔。

&emsp;&emsp;对于基于0的坐标系，序列的第一个碱基是位置0，最后一个碱基的位置是序列的长度-1。在这个基于0的坐标系中，我们使用半闭合、半开间隔。无可否认，这些半闭半开的区间一开始可能有点不直观-在解释这些区间时借用一些数学符号是最容易的。对于某些开始和结束位置，半闭合、半开间隔被写为[开始，结束)。括号表示位置包括在间隔范围内(换句话说，间隔在这一端闭合)，而圆括号表示位置被排除在间隔范围内(间隔在这一端打开)。因此，像[1，5)这样的半闭半开区间包括位置1，2，3和4的碱基(如图9-2所示)。你可能想知道为什么我们在地球上会使用一个不包括结束位置的系统，但是我们将在讨论基于1的坐标系之后再讨论这个问题。事实上，如果您熟悉Python，您已经见过这种类型的间隔系统：Python的字符串(和列表)是0索引的，并使用半闭半开间隔来索引字符串的部分：
```r
>>“CTTACTTCGAAGGCTG”[1：5]
‘TTAC’
```

&emsp;&emsp;第二种类型是基于1的。正如你可能已经猜到的那样，对于基于1的系统，序列的第一个碱基被赋予位置1。因为位置的计数就像我们计算自然数一样，序列中的最后一个位置总是等于它的长度。对于我们在生物信息学中遇到的基于1的系统，范围被表示为封闭的间隔。在我们前面看到的符号中，这只是[start，end]，这意味着开始和结束位置都包含在我们的范围内。如图9-2所示，覆盖基于0的范围[1，5]的相同碱基被覆盖在基于1的范围[2，5]中。R对其向量和字符串使用基于1的索引，并且使用substr()提取字符串的一部分使用闭合间隔：
```r
 >substr(“CTTACTTCGAAGGCTG”，2，5)
[1]“TTAC”
```

&emsp;&emsp;如果你不能理解，不要太担心-这些东西确实令人困惑。现在，重要的是你意识到了这两种类型，并注意哪一种适用于你正在处理的数据。

![9-2](../img/9-2.png)
图9-2。基于0和基于1的坐标系上的范围(直线表示范围，开放圆表示开放区间端点，闭合圆表示闭合端点)

&emsp;&emsp;因为我们大多数人习惯于用自然数(即1，2，3等)计数，所以一开始有倾向于以1为基础的系统。然而，这两种系统都有优点和缺点。例如，在基于0的系统中，为了计算一个范围跨度(有时称为范围宽度)有多少个碱基，我们使用end-start。这是简单而直观的。对于基于1的系统，我们将使用不太直观的end-start+1。基于0的系统的另一个很好的特性是它支持零宽度特征，而对于基于1的系统，支持的最小宽度是1基(尽管有时像[30，29]这样的范围用于零宽度特征)。如果我们需要表示碱基之间的特征，例如限制酶切割DNA序列的地方，Zerowidth特征是有用的。例如，在图9-2中的位置[12，12)切割的限制性内切酶会留下片段CTTACTTCGAAGG和CTG。

表9-1、常见生物信息学格式的范围类型
```python
# todo
```

&emsp;&emsp;我们需要担心的第二个细节是：链。没什么可说的，除了：你在工作中需要更用心。因为DNA是双链的，基因组特征可以位于任何一条链上。在几乎所有的范围格式中(BLAST结果是例外)，范围的坐标在参考序列的前向链上给出。然而，基因组特征可以在正向或反向链上。例如，代表蛋白质编码区的范围仅在给定适当的链的情况下才具有生物学意义。如果蛋白质编码特征在正向链上，那么这个范围下的核苷酸序列就是转录过程中产生的mRNA。相反，如果蛋白质编码特征在反转链上，则该范围下的核苷酸序列的反向互补是在转录过程中创建的mRNA序列。

&emsp;&emsp;在比较特征时，我们还需要考虑串。假设你已经将序列读数与一个参考基因组进行比对，并且你想要计算有多少个读数重叠了一个特定的基因。每个对齐的读操作在其对齐的区域上创建一个范围，我们想要计算这些对齐的读操作范围中有多少与基因范围重叠。然而，关于测序读取来自哪条链的信息在测序过程中丢失(尽管现在有特定于链的RNA-seq协议)。对齐的读数将映射到两条链，并且它们映射到哪条链是没有信息的。因此，当计算与我们想要忽略的链的基因区域重叠时，应该计算重叠，而不管对齐的读取的链和基因的链是否相同。仅计算与该基因具有相同链的重叠对齐读数将导致低估可能来自该基因区域的读数。

## 用GenomicRanges交互式介绍范围数据
&emsp;&emsp;为了获得将数据表示为染色体上的范围并使用这些数据的感觉，我们将逐步创建范围并使用Bioconductor包IRanges和GenomicRanges的范围操作。与第8章中的示例一样，这些示例将是交互式的，因此您可以轻松地探索和处理数据。通过交互式示例，我们还将看到在使用范围操作时需要注意的细微缺陷。

## 安装和使用Bioconductor软件包

&emsp;&emsp;在我们开始使用范围数据之前，让我们先了解一下Bioconductor并安装其必需的软件包。Bioconductor是一个开源软件项目，它创建R生物信息包并充当它们的存储库；它强调用于高通量数据的工具。在本节中，我们将触及Bioconductor的一些核心软件包：

*GenomicRanges*

用于表示和处理基因组范围。

*GenomicFeatures*

用于表示和处理代表基因模型和基因组的其他特征(基因、外显子、UTR、转录本等)的范围。

*Biostrings and BSgenome*

用于操作R中的基因组序列数据(我们将介绍用于从范围中提取序列的这些包的子集)。

*RTracklayer。*

用于阅读常用生物信息学格式，如BED、GTF/GFF和WIG

&emsp;&emsp;Bioconductor的包装系统与综合R档案网(CRAN)的包装系统略有不同。Bioconductor包装按设定的时间表发布，一年两次。每个版本都与R的一个版本相协调，使得Bioconductor的版本与特定的R版本相关联。这种严格协调背后的动机是，它允许在发布给公众使用之前对包进行彻底的测试。此外，因为Bioconductor项目中有相当多的代码重用，所以这可以确保Bioconductor版本中的所有包版本彼此兼容。对于用户来说，最终结果是包按预期工作，并且在您使用它之前已经过了严格的测试(当您的科学结果依赖于软件可靠性时，这是很好的！)。如果您出于某种原因需要包的尖端版本，总是可以与他们的开发分支一起工作。

&emsp;&emsp;安装Bioconductor包时，我们使用biocLite()函数。biocLite()为您的R版本(及其相应的Bioconductor版本)安装正确版本的包。我们可以通过运行以下命令来安装Bioconductor的主要软件包(不过，首先要确保您的R版本是最新的)：
```r
>source("http://bioconductor.org/bioclite")
> biocLite()
```
&emsp;&emsp;前面几行安装的一个包是BiocInstaller，它包含函数biocLite()。我们可以使用biocLite()安装GenomicRanges包，我们将在本章中使用它：
```r
>biocLite(“GenomicRanges”)
```
&emsp;&emsp;这足以开始使用本章中的Range示例。如果您希望稍后安装其他软件包(在其他R会话中)，请先加载带有库(BiocInstaller)的BiocInstaller软件包。BiocLite()会在您的一些包过期并需要升级时通知您(它可以自动为您进行升级)。还可以使用biocUpdatePackages()手动更新Bioconductor(和cran)包。因为Bioconductor的包都绑定到特定的版本，所以可以确保包与biocValid()一致。如果使用Bioconductor包遇到意外错误，最好在调试之前运行biocUp datePackages()和biocValid()。

&emsp;&emsp;除了精心的发布周期，以促进包的稳定性，Bioconductor也有广泛的，优秀的文档。每个包的最好、最新的文档将始终位于Bioconductor。每个包都有一个完整的参考手册，涵盖包中包含的所有函数和类，以及一个或多个深入的小插图。Vignettes使用包逐步介绍了许多示例和常见工作流。例如，请参阅GenomicRanges参考手册和Vignettes。我强烈建议您阅读打算使用的所有Bioconductor包的Vignettes-它们写得非常好，并且进入了许多有用的细节。

## 使用IRanges存储泛型范围

&emsp;&emsp;在开始使用基因组范围之前，我们将用通用范围(即表示任何类型序列上的元素的邻接子序列的范围)弄湿我们的脚。以这种方式开始可以让我们更加专注于抽象地思考范围，以及如何使用范围操作来解决问题。在生物信息学中使用范围的真正力量不是来自特定的范围库实现，而是使用范围抽象解决问题(回想一下Pólya在本章开头引用的话)。要在现实世界的生物信息学中最大限度地利用范围库，您需要掌握这种抽象和“范围思维”。

&emsp;&emsp;本章第一部分的目的是通过使用Bioconductor的IRanges包来教你范围思维。这个包实现了通用范围和序列的数据结构，以及在R中使用这些类型的数据所必需的函数。本节将大量使用可视化来建立关于范围操作所做的事情的直觉。在本章的后面，我们将学习GenomicRanges包，它通过处理诸如染色体名称和链之类的生物细节来扩展IRanges。这种方法在软件开发中很常见：实现比您需要的更通用的解决方案，然后扩展通用解决方案来解决特定的问题(有关这一点，请参阅xkcd的“通用问题”漫画)。

&emsp;&emsp;让我们从使用IRanges创建一些范围开始。首先，加载IRanges包。IRanges软件包是我们之前使用biocLite()安装的GenomicRanges软件包的依赖项，因此它应该已经安装了：
```r
> library(IRanges) # you might see some package startup
 # messages when you run this
```

&emsp;&emsp;我们使用IRanges包创建的范围称为IRanges对象。每个IRanges对象都有任何范围的两个基本组成部分：开始和结束位置。我们可以使用IRanges()函数创建范围。例如，将使用以下命令创建从位置4开始到位置13结束的范围：
```r
> rng &lt;- IRanges(start=4, end=13)
> rng
IRanges of length 1
 start end width
[1] 4 13 10
```

&emsp;&emsp;需要注意的最重要的事实：IRanges(和GenomicRanges)是基于1的，并使用闭合间隔。采用基于1的系统以与R的基于1的系统一致(回想一下R向量中的第一个元素具有索引1)。

&emsp;&emsp;也可以通过指定范围的宽度以及开始或结束位置来创建范围：
```r
>IRanges(start=4, width=3)
IRanges of length 1
 start end width
[1] 4 6 3
> IRanges(end=5, width=5)
IRanges of length 1
 start end width
[1] 1 5 5
```
&emsp;&emsp;此外，IRanges()构造函数(创建新对象的函数)可以采用向量参数，从而创建包含许多范围的IRanges对象：
```r
> x &lt;- IRanges(start=c(4, 7, 2, 20), end=c(13, 7, 5, 23))
> x
IRanges of length 4
 start end width
[1] 4 13 10
[2] 7 7 1
[3] 2 5 4
[4] 20 23 4
```

&emsp;&emsp;与许多R对象一样，可以为每个范围指定一个名称。这可以通过在IRanges中设置Names参数或使用函数Names()来实现：

```r
> names(x) &lt;- letters[1:4]
> x
IRanges of length 4
 start end width names
[1] 4 13 10 a
[2] 7 7 1 b
[3] 2 5 4 c
[4] 20 23 4 d
```
&emsp;&emsp;这四个范围如图9-3所示。如果您希望尝试绘制范围，我用来创建这些图的函数plotIRanges()的源代码可以在本书的GitHub存储库的本章目录中找到。

&emsp;&emsp;虽然在外部x可能看起来像DataFrame，但它不是-它是一个具有类IRanges的特殊对象。在第191页的“R中的因素和类”中，我们了解到对象的类决定了它的行为以及我们在R中如何与它交互。很多生物导体都是由对象和类构建的。使用函数class()，我们可以看到它是一个IRanges对象：
```r
> class(x)
[1] "IRanges"
attr(,"package")
[1] "IRanges"
```
&emsp;&emsp;IRanges对象包含有关内部创建的范围的所有信息。如果您想知道引擎盖下面是什么，请调用str(X)查看一下。与我们使用访问器函数level()访问因子的级别(“R中的因子和类”(第191页)类似，我们使用访问器函数获取IRanges对象的部分。例如，可以使用start()、end()和width()方法访问此对象中每个范围的开始位置、结束位置和宽度：
```r
> start(x)
[1] 4 7 2 20
> end(x)
[1] 13 7 5 23
> width(x)
[1] 10 1 4 4
```
&emsp;&emsp;这些函数还与<-配合使用，以设置开始、结束和宽度位置。例如，我们可以使用以下方法将范围的结束位置增加4个位置：

&emsp;&emsp;图9-4显示了扩展结束位置之前和之后的IRanges对象。请注意，这些曲线图中的y位置是不相关的；选择它是为了可以清楚地显示范围。
![9-4](../img/9-4.png)
图9-4。在将范围结束位置扩展4之前和之后
range()方法返回IRanges对象中保存的范围的跨度：
```r
>range(x)
IRanges of length 1
 start end width
[1] 2 27 26
```
&emsp;&emsp;我们可以使用数字、逻辑或字符(名称)索引对IRanges进行子集设置，就像我们对任何其他R对象(向量、数据框、矩阵)一样：
```r
> x[2:3]
IRanges of length 2
 start end width names
[1] 7 11 5 b
[2] 2 9 8 c
> start(x) < 5
[1] TRUE FALSE TRUE FALSE
> x[start(x) < 5]
IRanges of length 2
 start end width names
[1] 4 17 14 a
[2] 2 9 8 c
> x[width(x) > 8]
IRanges of length 1
 start end width names
[1] 4 17 14 a
> x['a']
IRanges of length 1
 start end width names
[1] 4 17 14 a
```
&emsp;&emsp;与dataframe一样，使用Width(X)>；8等语句创建的逻辑向量建立索引是选择感兴趣的范围子集的一种强大方法。
&emsp;&emsp;还可以使用函数c()轻松合并范围，就像我们用来组合向量一样：

```r
> a <- IRanges(start=7, width=4)
> b <- IRanges(start=2, end=5)
> c(a, b)
IRanges of length 2
 start end width
[1] 7 10 4
[2] 2 5 4
```

&emsp;&emsp;有了IRanges对象的基础知识，我们现在准备看一些基本的范围操作。

&emsp;&emsp;基本范围运算：算术、变换和集合运算
在上一节中，我们看到了IRanges对象如何方便地存储通用范围数据。到目前为止，IRanges看起来可能只是一个保存范围数据的dataframe；在本节中，我们将了解为什么这些对象要多得多。使用特殊类来存储范围的目的是，它允许方法对这种类型的数据执行专门的操作。IRanges包中包含的处理IRanges对象的方法简化并解决了许多基因组数据分析任务。这些相同的方法在GenomicRanges包中实现，并且在Grange对象上的工作方式与对一般IRanges对象的工作方式类似。

&emsp;&emsp;首先，IRanges对象可以使用+、-和*等算术运算来增长或缩小(除法运算符/对范围没有意义，因此不受支持)。增长范围对于添加缓冲区非常有用。例如，我们可能想要在编码区的上游和下游包括几千个碱基的序列，而不仅仅是编码区本身。对于IRanges对象，加法(减法)将通过向其添加(减去)的值对称地增长(缩小)一个范围：

```r
> x <- IRanges(start=c(40, 80), end=c(67, 114))
> x + 4L
IRanges of length 2
 start end width
[1] 36 71 36
[2] 76 118 43
> x - 10L
 start end width
[1] 50 57 8
[2] 90 104 15
```
!['warning'](../img/warning.png)
!['note'](../img/note.png)
!['suggestion'](../img/suggestion.png)
!['suggestion'](../img/suggestion.png)